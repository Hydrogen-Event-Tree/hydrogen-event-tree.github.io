<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HIAD Event Dashboard</title>
  <style>
    :root {
      --bg: #f6f7fb;
      --panel: #eef0f5;
      --card: #ffffff;
      --border: #d6d9e0;
      --text: #1f2430;
      --muted: #566072;
      --accent: #0f8f9b;
      --accent-2: #b91c1c;
      --badge-bg: #e1f3f5;
      --metric-bg: #f0f2f7;
      --code-bg: #f7f8fb;
      --code-border: #d8dbe4;
      --table-head-bg: #eef1f7;
      --active-bg: #dfe4f3;
      --header-bg: linear-gradient(135deg, #f5f6fb 0%, #e7eaf5 100%);
      --tree-bg: #ffffff;
      --tree-node-bg: #f1f3f7;
      --tree-padding-x: 16px;
      --title-font: "SF Pro Display", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "IBM Plex Mono", "SFMono-Regular", Menlo, Consolas, monospace;
    }
    header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--header-bg);
      letter-spacing: 0.02em;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    h1 {
      margin: 0;
      font-size: 20px;
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-family: var(--title-font);
      color: var(--accent);
    }
    h1 .title-accent {
      color: var(--accent);
      font-weight: 600;
    }
    h1 .brand sub {
      font-size: 0.6em;
      line-height: 0;
      vertical-align: sub;
    }
    .header-left {
      display: inline-flex;
      align-items: center;
      gap: 14px;
    }
    .controls {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    .about-button {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-family: var(--title-font);
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.02em;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }
    .about-button:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    .header-tabs {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      margin-left: 12px;
    }
    .controls label {
      font-size: 12px;
      color: var(--muted);
    }
    .controls select {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 8px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
    }
    .layout {
      display: grid;
      grid-template-columns: 420px 1fr;
      height: calc(100vh - 80px);
      overflow: hidden;
    }
    .sidebar {
      border-right: 1px solid var(--border);
      overflow-y: auto;
      background: var(--panel);
      scrollbar-color: var(--border) transparent;
    }
    .list-controls {
      position: sticky;
      top: 0;
      z-index: 2;
      padding: 12px 14px 8px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }
    .list-reset {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
    }
    .list-reset:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .content {
      padding: 18px 20px;
      overflow-y: auto;
      scrollbar-color: var(--border) transparent;
    }
    .list-empty {
      padding: 24px 16px;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }
    .event {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s ease;
      position: relative;
      user-select: none;
    }
    .event:hover {
      background: var(--metric-bg);
    }
    .event.active {
      background: var(--active-bg);
      border-left: 3px solid var(--accent);
    }
    .event-title {
      font-weight: 600;
      color: var(--text);
      font-family: var(--title-font);
      padding-left: 6px;
      padding-bottom: 4px;
      padding-right: 10px;
      font-size: 18px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px 16px;
      margin-bottom: 14px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.14);
    }
    .card h2 {
      margin: 0 0 10px 0;
      font-size: 15px;
      color: var(--accent);
      letter-spacing: 0.01em;
    }
    .card h2.card-title-main {
      margin: 0 0 2px 0;
      font-size: 22px;
      color: var(--text);
      letter-spacing: 0.01em;
      font-family: var(--title-font);
    }
    .muted {
      color: var(--muted);
    }
    pre {
      background: var(--code-bg);
      border: 1px solid var(--code-border);
      border-radius: 8px;
      padding: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
      line-height: 1.5;
      color: var(--text);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 6px;
      font-size: 13px;
    }
    th, td {
      border: 1px solid var(--border);
      padding: 8px 10px;
      text-align: left;
    }
    th {
      background: var(--table-head-bg);
      color: var(--text);
      font-weight: 600;
    }
    .answers-block {
      margin-bottom: 12px;
    }
    .answers-title {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .answer-table col.col-key { width: 45%; }
    .answer-table col.col-value { width: 35%; }
    .answer-table col.col-conf { width: 20%; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--badge-bg);
      color: var(--text);
      font-size: 12px;
      margin: 4px 8px 4px 0;
    }
    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 3px;
    }
    .details-header {
      position: relative;
      padding-right: 110px;
    }
    .details-header .badge {
      position: absolute;
      top: 0;
      right: 0;
      white-space: nowrap;
    }
    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 2px;
      font-size: 12px;
      color: var(--text);
    }
    .status-dot {
      position: absolute;
      top: 10px;
      right: 12px;
      width: 11px;
      height: 11px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--accent);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.2);
    }
    .status-dot.excluded {
      background: var(--accent-2);
    }
    .status-dot.included {
      background: #3aa774;
    }
    .metric {
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--metric-bg);
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid var(--border);
      background: var(--badge-bg);
      color: var(--accent);
    }
    .badge.bad {
      color: var(--accent-2);
    }
    .badge.good {
      color: #3aa774;
    }
    .pill-value {
      font-weight: 700;
    }
    .status-flag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--badge-bg);
      font-weight: 600;
      color: var(--text);
    }
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background-color: rgba(0,0,0,0.16);
      border-radius: 8px;
      border: 2px solid transparent;
    }
    #details.empty-state {
      text-align: center;
      padding-top: 140px;
    }
    #details {
      max-width: 1000px;
      will-change: opacity, transform;
    }
    #details.details-animate {
      animation: detailsSwap 220ms ease;
    }
    @keyframes detailsSwap {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      #details.details-animate {
        animation: none;
      }
    }
    .card-section {
      margin-top: 10px;
    }
    .tab-button {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      font-family: var(--title-font);
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.01em;
      transition: background 0.15s ease, border-color 0.15s ease;
    }
    .tab-button.active {
      background: var(--active-bg);
      border-color: var(--accent);
      color: var(--text);
      box-shadow: none;
    }
    .all-events-button {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      font-family: var(--title-font);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 10px;
    }
    .tab-panel {
      display: none;
      will-change: opacity, transform;
    }
    .tab-panel.active {
      display: block;
      animation: tabSwap 220ms ease;
    }
    @keyframes tabSwap {
      from {
        opacity: 0;
        transform: translateY(12px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .tab-panel.active {
        animation: none;
      }
    }
    .tree-layout {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 16px;
      flex-wrap: wrap;
    }
    .tree-controls-card {
      width: 290px;
      flex: 0 0 290px;
      margin-bottom: 0;
    }
    .control-block {
      margin-bottom: 12px;
    }
    .control-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .control-options {
      display: grid;
      gap: 8px;
    }
    .control-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--badge-bg);
    }
    .control-option input {
      accent-color: var(--accent);
      width: 14px;
      height: 14px;
    }
    .control-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .control-title {
      font-weight: 600;
      font-size: 13px;
      color: var(--text);
    }
    .control-subtitle {
      color: var(--muted);
      font-size: 12px;
    }
    .tree-card {
      max-width: none;
      width: 100%;
      flex: 1 1 auto;
      margin: 0;
      padding: 0;
      background: transparent;
      border: none;
      box-shadow: none;
    }
    .tree-stack {
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 1 1 auto;
      min-width: 0;
    }
    .tree-card-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 0;
    }
    .tree-title {
      margin: 0;
      font-size: 18px;
      color: var(--text);
      font-family: var(--title-font);
      letter-spacing: 0.01em;
    }
    .tree-status {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .tree-wrapper {
      position: relative;
      min-height: 421px;
      background: var(--tree-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 70px var(--tree-padding-x) 0 var(--tree-padding-x);
      overflow-x: auto;
      overflow-y: hidden;
      max-width: 100%;
      margin: 0 auto;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
      transition: height 260ms ease;
    }
    .sort-control {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    body[data-view="tree"] .sidebar {
      display: none;
    }
    body[data-view="tree"] .layout {
      grid-template-columns: 1fr;
    }
    body[data-view="tree"] .sort-control {
      display: none;
    }
    .tree-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .tree-node {
      position: absolute;
      transform: translate(-50%, -50%) translate(var(--shift-x, 0px), var(--shift-y, 0px));
      width: 129px;
      padding: 6px 9px;
      background: var(--tree-node-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 4px 5px rgba(0,0,0,0.07);
      font-size: 12px;
      line-height: 1.35;
      transition: border-color 150ms ease, box-shadow 150ms ease, height 220ms ease, transform 260ms ease;
    }
    .tree-node.clickable {
      cursor: pointer;
    }
    .tree-node .node-title {
      font-weight: 700;
      color: var(--text);
      margin-bottom: 0;
    }
    .tree-node .node-prob {
      color: var(--muted);
      font-size: 10px;
    }
    .tree-node.highlight {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(15, 143, 155, 0.18), 0 4px 10px rgba(0,0,0,0.18);
    }
    .tree-node .node-meta {
      color: var(--muted);
      font-size: 10px;
    }
    .tree-node.with-distribution {
      width: 135px;
    }
    @media (prefers-reduced-motion: reduce) {
      .tree-node {
        transition: none;
      }
      .tree-column-label {
        transition: none;
      }
      .tree-wrapper {
        transition: none;
      }
    }
    .tree-column-label {
      position: absolute;
      top: 12px;
      transform: translateX(-50%) translate(var(--shift-x, 0px), var(--shift-y, 0px));
      font-size: 12px;
      color: var(--text);
      font-weight: 700;
      text-align: center;
      white-space: pre;
      padding: 6px 8px;
      border-radius: 8px;
      background: var(--badge-bg);
      border: 1px solid var(--border);
      transition: transform 260ms ease;
    }
    @media (max-width: 1400px) {
      .tree-title {
        font-size: 17px;
      }
      .tree-status {
        font-size: 11px;
      }
      .tree-controls-card .card-title-main {
        font-size: 21px;
      }
      .control-label {
        font-size: 11px;
      }
      .control-title {
        font-size: 12px;
      }
      .control-subtitle {
        font-size: 11px;
      }
      .tree-node {
        font-size: 11px;
        padding: 6px 6px;
        width: 115px;
      }
      .tree-node.with-distribution {
        width: 115px;
      }
      .tree-node .node-prob {
        font-size: 9px;
      }
      .tree-node .node-meta {
        font-size: 9px;
      }
      .tree-column-label {
        font-size: 11px;
      }
      .tree-legend {
        font-size: 11px;
      }
      .cred-level {
        font-size: 11px;
      }
      .controls-disclaimer {
        font-size: 10px;
      }
      .beta-tooltip-title {
        font-size: 11px;
      }
      .beta-tooltip-meta,
      .beta-tooltip-range {
        font-size: 10px;
      }
    }
    @media (max-width: 890px) {
      .tree-wrapper {
        padding: 70px 8px 0 8px;
      }
      .tree-node {
        padding: 6px 9px;
      }
      .tree-node.tree-root {
        width: 70px;
      }
    }
    @media (max-width: 820px) {
      .tree-wrapper {
        padding: 70px 4px 0 4px;
      }
      .tree-node {
        width: 98px;
        padding: 5px 7px;
        font-size: 10px;
      }
      .tree-node.tree-root {
        width: 70px;
      }
      .tree-node.with-distribution {
        width: 98px;
      }
      .tree-node .node-prob {
        font-size: 9px;
      }
      .tree-node .node-meta {
        font-size: 9px;
      }
      .tree-column-label {
        font-size: 11px;
      }
      .tree-legend {
        font-size: 11px;
      }
      .tree-status {
        font-size: 11px;
      }
    }
    @media (max-width: 723px) {
      .tree-node {
        width: 88px;
        padding: 5px 6px;
      }
      .tree-node.with-distribution {
        width: 93px;
      }
      .tree-node.tree-root {
        width: 70px;
      }
      .node-distribution canvas {
        height: 30px !important;
      }
      .tree-node .node-prob {
        font-size: 8px;
      }
    }
    @media (max-width: 650px) {
      .tree-node {
        width: 78px;
      }
      .tree-node.with-distribution {
        width: 83px;
      }
      .tree-node.tree-root {
        width: 60px;
      }
    }
    @media (max-width: 600px) {
      .tree-node {
        padding: 5px 4px;
      }
      .tree-node.with-distribution {
        width: 66px;
      }
    }
    @media (max-width: 565px) {
      .tree-node {
        width: 65px;
      }
      .tree-node.with-distribution {
        width: 65px;
      }
      .tree-column-label {
        font-size: 10px;
      }
    }
    @media (max-width: 490px) {
      .tree-node {
        width: 63px;
        font-size: 9px;
      }
      .tree-node.with-distribution {
        width: 63px;
      }
      .tree-node.tree-root {
        width: 58px;
      }
      .tree-column-label {
        padding: 3px 5px;
      }
    }
    @media (max-width: 1190px) {
      .tree-layout {
        flex-direction: column;
        align-items: stretch;
      }
      .tree-controls-card {
        width: 100%;
        flex: 1 1 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
        gap: 12px;
      }
      .tree-controls-card .card-header {
        grid-column: 1 / -1;
        margin-bottom: 0;
      }
      .tree-controls-card .control-block {
        margin-bottom: 0;
      }
      .tree-controls-card .controls-disclaimer {
        grid-column: 1 / -1;
        margin-top: 0;
        padding-top: 0;
      }
    }
    @media (max-width: 1000px) {
      .layout {
        grid-template-columns: 320px 1fr;
      }
      .content {
        padding: 18px 10px;
      }
      .event {
        padding: 10px 12px;
      }
      .event-title {
        font-size: 16px;
      }
      .metrics {
        font-size: 11px;
      }
    }
    @media (max-width: 820px) {
      .layout {
        grid-template-columns: 280px 1fr;
      }
      .event-title {
        font-size: 15px;
      }
      .metrics {
        font-size: 10px;
      }
    }
    @media (max-width: 710px) {
      .layout {
        grid-template-columns: 240px 1fr;
      }
      .content {
        padding: 18px 5px;
      }
      .event-title {
        font-size: 14px;
        padding-left: 2px;
        padding-right: 2px;
      }
      .metrics {
        font-size: 9px;
      }
      .status-dot {
        display: none;
      }
      .event {
        padding: 7px 7px;
      }
      .list-controls {
        padding: 10px 7px 6px;
      }
      .list-empty {
        padding: 20px 7px;
      }
    }
    @media (max-width: 550px) {
      header {
        gap: 0;
      }
      .layout {
        grid-template-columns: 1fr;
        position: relative;
      }
      .header-left {
        flex: 1;
      }
      .header-tabs {
        margin-left: auto;
      }
      .sidebar {
        position: absolute;
        inset: 0;
        width: 100%;
        border-right: none;
        z-index: 20;
        display: none;
        box-shadow: 0 10px 24px rgba(0,0,0,0.18);
      }
      body[data-list-overlay="open"] .sidebar {
        display: block;
      }
      .all-events-button {
        display: inline-flex;
        width: 100%;
        justify-content: center;
      }
      .event {
        padding: 10px 12px;
      }
      .event-title {
        font-size: 16px;
        padding-left: 4px;
        padding-right: 6px;
      }
      .metrics {
        font-size: 11px;
      }
    }
    @media (max-width: 450px) {
      header {
        padding: 10px 16px;
      }
      h1 {
        font-size: 18px;
      }
      .tab-button {
        padding: 8px 10px;
      }
    }
    .node-distribution {
      margin-top: 2px;
      padding-top: 0;
      width: 100%;
      max-width: 120px;
      margin-left: auto;
      margin-right: auto;
      display: grid;
      gap: 0;
    }
    .node-distribution canvas {
      width: 100%;
      height: 40px;
      display: block;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 6px;
    }
    .prob-bounds {
      color: var(--muted);
    }
    .tree-legend {
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
    }
    .cred-levels {
      display: flex;
      gap: 8px;
      margin-top: 6px;
      flex-wrap: wrap;
    }
    .cred-level {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--badge-bg);
      font-size: 12px;
    }
    .cred-level input {
      accent-color: var(--accent);
      width: 14px;
      height: 14px;
    }
    .cred-levels.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    .beta-tooltip {
      position: fixed;
      left: 0;
      top: 0;
      z-index: 30;
      width: 240px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card);
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
      pointer-events: none;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.12s ease, transform 0.12s ease;
    }
    .beta-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .beta-tooltip-title {
      font-size: 12px;
      font-weight: 700;
      color: var(--text);
    }
    .beta-tooltip-meta,
    .beta-tooltip-range {
      font-size: 11px;
      color: var(--muted);
      margin-top: 4px;
    }
    .beta-tooltip canvas {
      width: 100%;
      height: 90px;
      display: block;
      margin-top: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    .controls-disclaimer {
      margin-top: 10px;
      padding-top: 6px;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
      font-family: var(--title-font);
    }
    .about-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
      padding: 20px;
      pointer-events: none;
      visibility: hidden;
      transition: visibility 0s linear 0.2s;
    }
    body[data-about-open="true"] .about-modal {
      pointer-events: auto;
      visibility: visible;
      transition-delay: 0s;
    }
    body[data-about-open="true"] {
      overflow: hidden;
    }
    .about-modal-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0);
      backdrop-filter: blur(0);
      opacity: 0;
      transition: background 0.2s ease, backdrop-filter 0.2s ease, opacity 0.2s ease;
    }
    body[data-about-open="true"] .about-modal-overlay {
      background: rgba(15, 23, 42, 0.38);
      backdrop-filter: blur(4px);
      opacity: 1;
    }
    .about-modal-card {
      position: relative;
      width: min(640px, 92vw);
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 18px 20px 20px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.2);
      z-index: 1;
      opacity: 0;
      transform: translateY(10px) scale(0.98);
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    body[data-about-open="true"] .about-modal-card {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    .about-modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 10px;
    }
    .about-title {
      margin: 0;
      font-size: 20px;
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-family: var(--title-font);
      letter-spacing: 0.02em;
      color: var(--accent);
    }
    .about-title .title-accent {
      color: var(--accent);
      font-weight: 600;
    }
    .about-title .brand sub {
      font-size: 0.6em;
      line-height: 0;
      vertical-align: sub;
    }
    .about-close {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--muted);
      font-size: 12px;
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: border-color 0.15s ease, color 0.15s ease;
    }
    .about-close:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    .about-body {
      font-size: 13px;
      line-height: 1.6;
      color: var(--text);
      font-family: var(--title-font);
    }
    .about-body a {
      color: var(--accent);
      font-weight: 700;
    }
    @media (max-width: 550px) {
      .about-modal-card {
        padding: 16px;
      }
      .about-title {
        font-size: 18px;
      }
      .about-body {
        font-size: 14px;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>
</head>
<body data-view="tree">
  <header>
    <div class="header-left">
      <h1>
        <span class="brand">H<sub>2</sub></span>
        <span class="title-accent">Event Tree</span>
      </h1>
      <div class="header-tabs">
        <button class="tab-button active" data-tab="tree">Event tree</button>
        <button class="tab-button" data-tab="details">Event details</button>
      </div>
    </div>
    <div class="controls">
      <button class="about-button" id="aboutButton" type="button">About</button>
    </div>
  </header>
  <div class="layout">
    <aside class="sidebar" id="list"></aside>
    <main class="content">
      <div class="tab-panel" id="detailsPanel">
        <div id="details" class="muted empty-state">Loading events…</div>
      </div>
      <div class="tab-panel active" id="treePanel">
        <div class="tree-layout">
          <div class="card tree-controls-card">
            <div class="card-header">
              <h2 class="card-title-main">Controls</h2>
            </div>
            <div class="control-block">
              <div class="control-label">Include events</div>
              <div class="control-options">
                <label class="control-option">
                  <input type="checkbox" id="includeNotPureH2" />
                  <div class="control-text">
                    <div class="control-title" id="labelNotPureH2">Include not pure H2</div>
                  </div>
                </label>
                <label class="control-option">
                  <input type="checkbox" id="includeNotGaseousH2" />
                  <div class="control-text">
                    <div class="control-title" id="labelNotGaseousH2">Include not gaseous H2</div>
                  </div>
                </label>
                <label class="control-option">
                  <input type="checkbox" id="includeNoLoc" />
                  <div class="control-text">
                    <div class="control-title" id="labelNoLoc">Include no loss of containment</div>
                  </div>
                </label>
                <label class="control-option">
                  <input type="checkbox" id="includeBarrierImmediate" />
                  <div class="control-text">
                    <div class="control-title" id="labelBarrierImmediate">Include barrier-stopped immediate ignition</div>
                  </div>
                </label>
                <label class="control-option">
                  <input type="checkbox" id="includeBarrierDelayed" />
                  <div class="control-text">
                    <div class="control-title" id="labelBarrierDelayed">Include barrier-stopped delayed ignition</div>
                  </div>
                </label>
              </div>
            </div>
            <div class="control-block">
              <div class="control-label">Uncertainty display</div>
              <div class="control-options">
                <label class="control-option">
                  <input type="checkbox" id="toggleCounts" checked />
                  <div class="control-text">
                    <div class="control-title">Sample count</div>
                  </div>
                </label>
                <label class="control-option">
                  <input type="checkbox" id="toggleProbability" checked />
                  <div class="control-text">
                    <div class="control-title">Probability</div>
                  </div>
                </label>
                <label class="control-option">
                  <input type="checkbox" id="toggleCredible" checked />
                  <div class="control-text">
                    <div class="control-title">Highest Posterior Density</div>
                    <div class="cred-levels" id="credLevelControls">
                      <label class="cred-level">
                        <input type="radio" name="credLevel" value="0.5" />
                        <span>50%</span>
                      </label>
                      <label class="cred-level">
                        <input type="radio" name="credLevel" value="0.68" />
                        <span>68%</span>
                      </label>
                      <label class="cred-level">
                        <input type="radio" name="credLevel" value="0.95" checked />
                        <span>95%</span>
                      </label>
                      <label class="cred-level">
                        <input type="radio" name="credLevel" value="0.99" />
                        <span>99%</span>
                      </label>
                    </div>
                  </div>
                </label>
                <label class="control-option">
                  <input type="checkbox" id="toggleDistributionAlways" checked />
                  <div class="control-text">
                    <div class="control-title">Always show distribution</div>
                    <div class="control-subtitle">Inline beta plots for Yes/No nodes</div>
                  </div>
                </label>
              </div>
            </div>
            <div class="control-block">
              <div class="control-label">Confidence</div>
              <div class="control-options">
                <label class="control-option">
                  <input type="checkbox" id="toggleConfidenceWeights" checked />
                  <div class="control-text">
                    <div class="control-title">Use confidence weights</div>
                    <div class="control-subtitle">Scale by reported confidence</div>
                  </div>
                </label>
              </div>
            </div>
            <div class="controls-disclaimer">
              Probabilities reflect HIAD responses, not real-world frequencies. Under-reporting or data gaps may make some accident types appear rarer/more frequent here than they are in reality.
            </div>
          </div>
          <div class="tree-stack">
            <div class="card tree-card">
              <div id="treeContainer" class="tree-wrapper"></div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>
  <div id="betaHoverTooltip" class="beta-tooltip" aria-hidden="true">
    <div class="beta-tooltip-title" id="betaTooltipTitle">Beta posterior</div>
    <div class="beta-tooltip-meta" id="betaTooltipMeta"></div>
    <canvas id="betaTooltipCanvas" width="220" height="48"></canvas>
    <div class="beta-tooltip-range" id="betaTooltipRange"></div>
  </div>
  <div id="aboutModal" class="about-modal" aria-hidden="true">
    <div class="about-modal-overlay" data-close="about"></div>
    <div class="about-modal-card" role="dialog" aria-modal="true" aria-labelledby="aboutTitle">
      <div class="about-modal-header">
        <h2 class="about-title" id="aboutTitle">
          <span class="title-accent">About</span>
          <span class="brand">H<sub>2</sub></span>
          <span class="title-accent">Event Tree</span>
        </h2>
        <button class="about-close" id="aboutClose" type="button" aria-label="Close">X</button>
      </div>
      <p class="about-body">
        This dashboard is fully based the data from <a href="https://minerva.jrc.ec.europa.eu/en/shorturl/capri/hiadpt" target="_blank">HIAD 2.1</a>, developed by the Joint Research Centre (JRC) of the European Commission, however they are not responsible for any of the data as displayed on this website and have not been involved in the production of the dashboard. We are thankful for their contributions and hope that this dashboard can help make their data even more accessible.<br><br>
        On the website, we have attempted to make it clear that the "Model Answers" which underpin the event tree is based on the output of a large language model (LLM) asked to classify the events in HIAD. This approach, like any, is imperfect but we have attempted to counteract this by, e.g., incorporating notions of certainty in model answers.<br><br>
        This dashboard was produced by Simon Halvdansson as part of the <a href="https://hydrogeni.no/" target="_blank">HYDROGENi</a> project at <a href="https://www.sintef.no/en/sintef-energy/" target="_blank">SINTEF Energy Research</a>. For additional details on the project which this dashboard is a part of, see the paper (link to be added) and <a href="https://github.com/SimonHalvdansson/H2-Event-Tree" target="_blank">GitHub repository</a>.
        
      </p>
    </div>
  </div>

  <script>
    const QUESTIONS = [
      { key: "continuous_release", short: "CR", long: "Continuous release" },
      { key: "immediate_ignition", short: "II", long: "Immediate ignition" },
      { key: "delayed_ignition", short: "DI", long: "Delayed ignition" },
      { key: "confined_space", short: "CS", long: "Confined space" },
    ];

    let eventsData = [];
    let sortMode = "id";
    let selectedIndex = null;
    let treeReady = false;
    let currentTab = "details";
    let showCounts = true;
    let showProbability = true;
    let showCredible = true;
    let credibleLevel = 0.95;
    let useConfidenceWeights = true;
    const showDistributionHover = true;
    let showDistributionAlways = true;
    let includeNotPureH2 = false;
    let includeNotGaseousH2 = false;
    let includeNoLoc = false;
    let includeBarrierImmediate = false;
    let includeBarrierDelayed = false;
    let activeTreeFilter = null;

    const TREE_OUTCOME_LABELS = [
      "Explosion",
      "Jet fire",
      "VCE / Flash fire",
      "Plume",
      "Fireball",
      "Flash fire",
      "VCE / Flash fire",
      "Puff",
    ];

    const TREE_LEAVES = [
      {
        id: "leaf_cr_y_imm_y_conf_y",
        parent: "conf_yes_cr_yes_imm_yes",
        conditions: { continuous_release: true, immediate_ignition: true, confined_space: true },
      },
      {
        id: "leaf_cr_y_imm_y_conf_n",
        parent: "conf_no_cr_yes_imm_yes",
        conditions: { continuous_release: true, immediate_ignition: true, confined_space: false },
      },
      {
        id: "leaf_cr_y_imm_n_del_y",
        parent: "del_yes_cr_yes",
        conditions: {
          continuous_release: true,
          immediate_ignition: false,
          delayed_ignition: true,
        },
      },
      {
        id: "leaf_cr_y_imm_n_del_n",
        parent: "del_no_cr_yes",
        conditions: {
          continuous_release: true,
          immediate_ignition: false,
          delayed_ignition: false,
        },
      },
      {
        id: "leaf_cr_n_imm_y_conf_y",
        parent: "conf_yes_cr_no_imm_yes",
        conditions: { continuous_release: false, immediate_ignition: true, confined_space: true },
      },
      {
        id: "leaf_cr_n_imm_y_conf_n",
        parent: "conf_no_cr_no_imm_yes",
        conditions: { continuous_release: false, immediate_ignition: true, confined_space: false },
      },
      {
        id: "leaf_cr_n_imm_n_del_y",
        parent: "del_yes_cr_no",
        conditions: {
          continuous_release: false,
          immediate_ignition: false,
          delayed_ignition: true,
        },
      },
      {
        id: "leaf_cr_n_imm_n_del_n",
        parent: "del_no_cr_no",
        conditions: {
          continuous_release: false,
          immediate_ignition: false,
          delayed_ignition: false,
        },
      },
    ].map((leaf, idx) => ({ ...leaf, label: TREE_OUTCOME_LABELS[idx] || "Outcome" }));

    const TREE_DECISIONS = [
      { id: "root", label: "LOC", parent: null, conditions: {}, column: "root" },
      {
        id: "cr_yes",
        label: "Yes",
        parent: "root",
        conditions: { continuous_release: true },
        column: "continuous",
      },
      {
        id: "cr_no",
        label: "No",
        parent: "root",
        conditions: { continuous_release: false },
        column: "continuous",
      },
      {
        id: "imm_yes_cr_yes",
        label: "Yes",
        parent: "cr_yes",
        conditions: { continuous_release: true, immediate_ignition: true },
        column: "immediate",
      },
      {
        id: "imm_no_cr_yes",
        label: "No",
        parent: "cr_yes",
        conditions: { continuous_release: true, immediate_ignition: false },
        column: "immediate",
      },
      {
        id: "imm_yes_cr_no",
        label: "Yes",
        parent: "cr_no",
        conditions: { continuous_release: false, immediate_ignition: true },
        column: "immediate",
      },
      {
        id: "imm_no_cr_no",
        label: "No",
        parent: "cr_no",
        conditions: { continuous_release: false, immediate_ignition: false },
        column: "immediate",
      },
      {
        id: "del_yes_cr_yes",
        label: "Yes",
        parent: "imm_no_cr_yes",
        conditions: {
          continuous_release: true,
          immediate_ignition: false,
          delayed_ignition: true,
        },
        column: "delayed",
      },
      {
        id: "del_no_cr_yes",
        label: "No",
        parent: "imm_no_cr_yes",
        conditions: {
          continuous_release: true,
          immediate_ignition: false,
          delayed_ignition: false,
        },
        column: "delayed",
      },
      {
        id: "del_yes_cr_no",
        label: "Yes",
        parent: "imm_no_cr_no",
        conditions: {
          continuous_release: false,
          immediate_ignition: false,
          delayed_ignition: true,
        },
        column: "delayed",
      },
      {
        id: "del_no_cr_no",
        label: "No",
        parent: "imm_no_cr_no",
        conditions: {
          continuous_release: false,
          immediate_ignition: false,
          delayed_ignition: false,
        },
        column: "delayed",
      },
      {
        id: "conf_yes_cr_yes_imm_yes",
        label: "Yes",
        parent: "imm_yes_cr_yes",
        conditions: {
          continuous_release: true,
          immediate_ignition: true,
          confined_space: true,
        },
        column: "confined",
      },
      {
        id: "conf_no_cr_yes_imm_yes",
        label: "No",
        parent: "imm_yes_cr_yes",
        conditions: {
          continuous_release: true,
          immediate_ignition: true,
          confined_space: false,
        },
        column: "confined",
      },
      {
        id: "conf_yes_cr_no_imm_yes",
        label: "Yes",
        parent: "imm_yes_cr_no",
        conditions: {
          continuous_release: false,
          immediate_ignition: true,
          confined_space: true,
        },
        column: "confined",
      },
      {
        id: "conf_no_cr_no_imm_yes",
        label: "No",
        parent: "imm_yes_cr_no",
        conditions: {
          continuous_release: false,
          immediate_ignition: true,
          confined_space: false,
        },
        column: "confined",
      },
    ];

    const TREE_COLUMNS = [
      { key: "root", label: "" },
      { key: "continuous", label: "Continuous\nrelease" },
      { key: "immediate", label: "Immediate\nignition" },
      { key: "delayed", label: "Delayed\nignition" },
      { key: "confined", label: "Confined\nspace" },
      { key: "outcome", label: "Outcome" },
    ];

    const TREE_DEFINITION = { decisions: TREE_DECISIONS, leaves: TREE_LEAVES, columns: TREE_COLUMNS };

    function escapeHtml(str) {
      if (str === null || str === undefined) return "";
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function barrierImmediate(ev) {
      return ev.barrier_stopped_immediate_ignition === true;
    }

    function barrierDelayed(ev) {
      return ev.barrier_stopped_delayed_ignition === true && ev.immediate_ignition !== true;
    }

    function shouldIncludeEvent(ev) {
      if (!includeNotPureH2 && ev.exclude_not_pure_h2) return false;
      if (!includeNotGaseousH2 && ev.exclude_not_gaseous_h2) return false;
      if (!includeNoLoc && ev.exclude_no_loc) return false;
      if (!includeBarrierImmediate && barrierImmediate(ev)) return false;
      if (!includeBarrierDelayed && barrierDelayed(ev)) return false;
      return true;
    }

    function isTreeFilterActive() {
      return !!(activeTreeFilter && Object.keys(activeTreeFilter).length);
    }

    function shouldShowInList(ev) {
      if (!isTreeFilterActive()) return true;
      if (!matchesConditions(ev, activeTreeFilter)) return false;
      return shouldIncludeEvent(ev);
    }

    function sortedItems() {
      const items = eventsData
        .map((ev, idx) => ({ ev, idx }))
        .filter(({ ev }) => shouldShowInList(ev));
      items.sort((a, b) => {
        const aExcluded = !!(
          a.ev.exclude_not_pure_h2 ||
          a.ev.exclude_not_gaseous_h2 ||
          a.ev.exclude_no_loc
        );
        const bExcluded = !!(
          b.ev.exclude_not_pure_h2 ||
          b.ev.exclude_not_gaseous_h2 ||
          b.ev.exclude_no_loc
        );
        if (sortMode === "include") {
          if (aExcluded !== bExcluded) return aExcluded ? 1 : -1;
        } else if (sortMode === "exclude") {
          if (aExcluded !== bExcluded) return aExcluded ? -1 : 1;
        } else if (sortMode === "id") {
          const aIdNum = Number(a.ev.event_id);
          const bIdNum = Number(b.ev.event_id);
          if (Number.isFinite(aIdNum) && Number.isFinite(bIdNum) && aIdNum !== bIdNum) {
            return aIdNum - bIdNum;
          }
          const aId = (a.ev.event_id ?? "").toString();
          const bId = (b.ev.event_id ?? "").toString();
          if (aId && bId && aId !== bId) return aId.localeCompare(bId);
        }
        return a.idx - b.idx;
      });
      return items;
    }

    function renderList() {
      const list = document.getElementById("list");
      list.innerHTML = "";
      const items = sortedItems();
      if (isTreeFilterActive()) {
        const controls = document.createElement("div");
        controls.className = "list-controls";
        const resetButton = document.createElement("button");
        resetButton.className = "list-reset";
        const eventLabel = items.length === 1 ? "event" : "events";
        resetButton.textContent = `Reset filter (${items.length} ${eventLabel})`;
        resetButton.addEventListener("click", () => {
          clearTreeFilter();
        });
        controls.appendChild(resetButton);
        list.appendChild(controls);
      }

      if (!items.length) {
        const empty = document.createElement("div");
        empty.className = "list-empty";
        empty.textContent = isTreeFilterActive()
          ? "No events match the current filters."
          : "No events to show.";
        list.appendChild(empty);
        return items;
      }

      items.forEach(({ ev, idx }) => {
        const div = document.createElement("div");
        div.className = "event";
        div.dataset.index = idx;
        const title = escapeHtml(ev.title || "Untitled Event");
        const excluded = !!(
          ev.exclude_not_pure_h2 ||
          ev.exclude_not_gaseous_h2 ||
          ev.exclude_no_loc
        );
        const statusDot = excluded ? "status-dot excluded" : "status-dot included";
        const outcome = escapeHtml(ev.outcome || inferOutcome(ev) || "Unknown");
        const answers = '<span class="metric">Outcome: ' + outcome + "</span>";
        div.innerHTML = `
          <span class="${statusDot}" aria-label="${excluded ? "Excluded" : "Included"}"></span>
          <div class="event-title">${title}</div>
          <div class="metrics">${answers}</div>
        `;
        div.addEventListener("click", () => selectEvent(idx));
        if (selectedIndex === idx) {
          div.classList.add("active");
        }
        list.appendChild(div);
      });
      return items;
    }

    function updateAllEventsButtonCount(count) {
      const button = document.querySelector(".all-events-button");
      if (!button) return;
      const total = Number.isFinite(count) ? count : sortedItems().length;
      button.textContent = `All events (${total})`;
    }

    function setDetailsMessage(message) {
      const details = document.getElementById("details");
      if (!details) return;
      details.classList.add("muted", "empty-state");
      details.textContent = message;
    }

    function syncSelectionWithList(items) {
      const hasSelection = selectedIndex !== null && items.some((item) => item.idx === selectedIndex);
      if (hasSelection) return;
      if (items.length) {
        selectEvent(items[0].idx);
        return;
      }
      selectedIndex = null;
      setDetailsMessage(isTreeFilterActive() ? "No events match the current filters." : "No events to show.");
    }

    function refreshList({ ensureSelection = false } = {}) {
      const items = renderList();
      if (ensureSelection) {
        syncSelectionWithList(items);
      }
      updateAllEventsButtonCount(items.length);
      return items;
    }

    function applyTreeFilter(conditions) {
      const nextFilter = conditions && Object.keys(conditions).length ? { ...conditions } : null;
      activeTreeFilter = nextFilter;
      hideBetaTooltip();
      setTab("details");
      refreshList({ ensureSelection: true });
    }

    function clearTreeFilter() {
      if (!isTreeFilterActive()) return;
      activeTreeFilter = null;
      refreshList({ ensureSelection: true });
    }

    function renderAnswers(ev) {
      const colgroup = `
        <col class="col-key" />
        <col class="col-value" />
        <col class="col-conf" />
      `;
      const qa = QUESTIONS.map(({ key, long }) => {
        const val = ev[key];
        const conf = ev[`${key}_confidence`];
        const value = val === true ? "Yes" : val === false ? "No" : "Unknown";
        const confidence = (conf === undefined || conf === null) ? "—" : conf;
        return `<tr><th>${escapeHtml(long)}</th><td>${escapeHtml(value)}</td><td>${escapeHtml(confidence)}/10</td></tr>`;
      }).join("");
      const barriers = [
        ["barrier_stopped_immediate_ignition", "Barrier stopped immediate ignition"],
        ["barrier_stopped_delayed_ignition", "Barrier stopped delayed ignition"],
      ].map(([key, label]) => {
        const val = ev[key];
        const value = val === true ? "Yes" : val === false ? "No" : "Unknown";
        return `<tr><th>${escapeHtml(label)}</th><td>${escapeHtml(value)}</td><td>—</td></tr>`;
      }).join("");
      const exclusions = [
        ["exclude_not_pure_h2", "Not pure H2"],
        ["exclude_not_gaseous_h2", "Not gaseous H2"],
        ["exclude_no_loc", "No loss of containment"],
      ].map(([key, label]) => {
        const val = ev[key];
        const value = val === true ? "Yes" : val === false ? "No" : "Unknown";
        return `<tr><th>${escapeHtml(label)}</th><td>${escapeHtml(value)}</td><td>—</td></tr>`;
      }).join("");
      return `
        <div class="answers-block">
          <div class="answers-title">Outcome questions</div>
          <table class="answer-table">
            <colgroup>${colgroup}</colgroup>
            <thead><tr><th>Key</th><th>Value</th><th>Confidence</th></tr></thead>
            <tbody>${qa}</tbody>
          </table>
        </div>
        <div class="answers-block">
          <div class="answers-title">BARRIERS</div>
          <table class="answer-table">
            <colgroup>${colgroup}</colgroup>
            <thead><tr><th>Barrier</th><th>Value</th><th></th></tr></thead>
            <tbody>${barriers}</tbody>
          </table>
        </div>
        <div class="answers-block">
          <div class="answers-title">Exclusions</div>
          <table class="answer-table">
            <colgroup>${colgroup}</colgroup>
            <thead><tr><th>Criteria</th><th>Value</th><th></th></tr></thead>
            <tbody>${exclusions}</tbody>
          </table>
        </div>
      `;
    }

    function matchesConditions(valueMap, conditions) {
      return Object.entries(conditions).every(([key, expected]) => valueMap[key] === expected);
    }

    function inferOutcome(ev) {
      const leaf = TREE_LEAVES.find((leaf) => matchesConditions(ev, leaf.conditions));
      return leaf ? leaf.label : "";
    }

    function countMatching(events, conditions) {
      return events.reduce((count, ev) => (matchesConditions(ev, conditions) ? count + 1 : count), 0);
    }

    function formatPercent(value) {
      if (!Number.isFinite(value)) return "0%";
      return `${(value * 100).toFixed(1)}%`;
    }

    function formatPercentRange(lower, upper) {
      const toText = (v) => (Number.isFinite(v) ? (v * 100).toFixed(1) : "—");
      return `${toText(lower)}-${toText(upper)}%`;
    }

    function formatBetaParam(value, useWeights) {
      if (!Number.isFinite(value)) return "—";
      if (useWeights) return value.toFixed(1);
      return String(Math.round(value));
    }

    function determineBranchKey(childConditions, parentConditions) {
      const parentKeys = new Set(Object.keys(parentConditions || {}));
      return Object.keys(childConditions || {}).find((key) => !parentKeys.has(key)) || null;
    }

    function confidenceWeight(ev, key, useWeights) {
      if (!key) return 1;
      if (!useWeights) return 1;
      const conf = Number(ev?.[`${key}_confidence`]);
      if (!Number.isFinite(conf)) return 0;
      const clamped = Math.min(Math.max(conf, 0), 10);
      return clamped / 10;
    }

    function betaIntervalWidth(invFn, lowerProb, mass) {
      const upperProb = lowerProb + mass;
      if (upperProb >= 1 || lowerProb < 0) return Infinity;
      const lower = invFn(lowerProb);
      const upper = invFn(upperProb);
      if (!Number.isFinite(lower) || !Number.isFinite(upper)) return Infinity;
      return upper - lower;
    }

    function betaHighestDensityInterval(alpha, betaParam, mass = 0.95) {
      const betaLib = typeof window !== "undefined" ? window.jStat : undefined;
      if (!betaLib || !betaLib.beta || typeof betaLib.beta.inv !== "function") return null;
      if (!(alpha > 0 && betaParam > 0) || !(mass > 0 && mass < 1)) return null;

      const inv = (p) => betaLib.beta.inv(p, alpha, betaParam);
      if (alpha <= 1 && betaParam > 1) {
        return { lower: 0, upper: inv(mass) };
      }
      if (betaParam <= 1 && alpha > 1) {
        return { lower: inv(1 - mass), upper: 1 };
      }
      if (alpha <= 1 && betaParam <= 1) {
        return null;
      }

      let a = 0;
      let b = 1 - mass;
      const phi = (Math.sqrt(5) - 1) / 2;
      let c = b - phi * (b - a);
      let d = a + phi * (b - a);
      let fc = betaIntervalWidth(inv, c, mass);
      let fd = betaIntervalWidth(inv, d, mass);
      for (let i = 0; i < 80; i++) {
        if (Math.abs(b - a) < 1e-5) break;
        if (fc < fd) {
          b = d;
          d = c;
          fd = fc;
          c = b - phi * (b - a);
          fc = betaIntervalWidth(inv, c, mass);
        } else {
          a = c;
          c = d;
          fc = fd;
          d = a + phi * (b - a);
          fd = betaIntervalWidth(inv, d, mass);
        }
      }
      const lowerProb = fc < fd ? c : d;
      if (lowerProb < 0 || lowerProb + mass >= 1) return null;
      const lower = inv(lowerProb);
      const upper = inv(lowerProb + mass);
      if (Number.isFinite(lower) && Number.isFinite(upper)) {
        return { lower, upper };
      }
      const etLower = inv((1 - mass) / 2);
      const etUpper = inv(1 - (1 - mass) / 2);
      if (Number.isFinite(etLower) && Number.isFinite(etUpper)) {
        return { lower: etLower, upper: etUpper };
      }
      return null;
    }

    function computeBetaPosterior(successWeight, totalWeight) {
      if (!Number.isFinite(totalWeight) || totalWeight <= 0) return null;
      const success = Math.max(0, Math.min(successWeight, totalWeight));
      const failure = Math.max(0, totalWeight - success);
      return { alpha: success + 1, beta: failure + 1 };
    }

    function getQuestionLabel(key) {
      const match = QUESTIONS.find((q) => q.key === key);
      return match ? match.long : "Decision";
    }

    function drawBetaPlot(canvas, alpha, betaParam, hdi) {
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const rect = canvas.getBoundingClientRect();
      const cssW = rect.width || canvas.width || 1;
      const cssH = rect.height || canvas.height || 1;
      const dpr = window.devicePixelRatio || 1;
      const targetW = Math.max(1, Math.round(cssW * dpr));
      const targetH = Math.max(1, Math.round(cssH * dpr));
      if (canvas.width !== targetW || canvas.height !== targetH) {
        canvas.width = targetW;
        canvas.height = targetH;
      }
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, cssW, cssH);
      const betaLib = typeof window !== "undefined" ? window.jStat : undefined;
      if (!betaLib || !betaLib.beta || typeof betaLib.beta.pdf !== "function") {
        ctx.fillStyle = "#888";
        ctx.font = "11px sans-serif";
        ctx.fillText("Beta distribution unavailable", 10, 22);
        return;
      }

      const style = getComputedStyle(document.documentElement);
      const lineColor = style.getPropertyValue("--text").trim() || "#1f2933";
      const fillColor = style.getPropertyValue("--accent").trim() || "#0f8f9b";
      const axisColor = style.getPropertyValue("--border").trim() || "#2a3244";
      const modeLineColor = lineColor;

      const padding = { left: 0, right: 0, top: 6, bottom: 4 };
      const innerW = cssW - padding.left - padding.right;
      const innerH = cssH - padding.top - padding.bottom;
      const baseY = padding.top + innerH;
      const eps = 1e-4;
      const samples = 320;
      const xs = [];
      const ys = [];
      let maxY = 0;
      for (let i = 0; i <= samples; i++) {
        const x = eps + ((1 - 2 * eps) * i) / samples;
        const y = betaLib.beta.pdf(x, alpha, betaParam);
        xs.push(x);
        ys.push(y);
        if (Number.isFinite(y) && y > maxY) maxY = y;
      }
      if (!Number.isFinite(maxY) || maxY <= 0) return;

      const xToPx = (x) => padding.left + x * innerW;
      const yToPx = (y) => baseY - (y / maxY) * innerH;

      ctx.strokeStyle = axisColor;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, baseY);
      ctx.lineTo(padding.left + innerW, baseY);
      ctx.stroke();

      if (hdi && Number.isFinite(hdi.lower) && Number.isFinite(hdi.upper)) {
        const start = Math.max(eps, Math.min(1 - eps, hdi.lower));
        const end = Math.max(eps, Math.min(1 - eps, hdi.upper));
        if (end > start) {
          ctx.beginPath();
          ctx.moveTo(xToPx(start), baseY);
          for (let i = 0; i < xs.length; i++) {
            const x = xs[i];
            if (x < start) continue;
            if (x > end) break;
            const y = ys[i];
            if (!Number.isFinite(y)) continue;
            ctx.lineTo(xToPx(x), yToPx(y));
          }
          const endY = betaLib.beta.pdf(end, alpha, betaParam);
          if (Number.isFinite(endY)) {
            ctx.lineTo(xToPx(end), yToPx(endY));
          }
          ctx.lineTo(xToPx(end), baseY);
          ctx.closePath();
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = fillColor;
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      if (alpha > 1 && betaParam > 1) {
        const modeX = (alpha - 1) / (alpha + betaParam - 2);
        const modeY = betaLib.beta.pdf(modeX, alpha, betaParam);
        if (Number.isFinite(modeY)) {
          const modePx = xToPx(modeX);
          const modePy = yToPx(modeY);
          ctx.strokeStyle = modeLineColor;
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 3]);
          ctx.beginPath();
          ctx.moveTo(modePx, baseY);
          ctx.lineTo(modePx, modePy);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      ctx.beginPath();
      xs.forEach((x, idx) => {
        const y = ys[idx];
        if (!Number.isFinite(y)) return;
        const px = xToPx(x);
        const py = yToPx(y);
        if (idx === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      });
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.6;
      ctx.stroke();
    }

    const betaTooltip = document.getElementById("betaHoverTooltip");
    const betaTooltipTitle = document.getElementById("betaTooltipTitle");
    const betaTooltipMeta = document.getElementById("betaTooltipMeta");
    const betaTooltipCanvas = document.getElementById("betaTooltipCanvas");
    const betaTooltipRange = document.getElementById("betaTooltipRange");
    let tooltipVisible = false;

    function hideBetaTooltip() {
      if (!betaTooltip) return;
      betaTooltip.classList.remove("visible");
      betaTooltip.setAttribute("aria-hidden", "true");
      tooltipVisible = false;
    }

    function positionBetaTooltip(clientX, clientY) {
      if (!betaTooltip) return;
      const offsetX = 12;
      const offsetY = 16;
      const rect = betaTooltip.getBoundingClientRect();
      let left = clientX + offsetX;
      let top = clientY + offsetY;
      if (left + rect.width + 8 > window.innerWidth) {
        left = window.innerWidth - rect.width - 8;
      }
      if (top + rect.height + 8 > window.innerHeight) {
        top = clientY - rect.height - 12;
      }
      if (left < 8) left = 8;
      if (top < 8) top = 8;
      betaTooltip.style.left = `${left}px`;
      betaTooltip.style.top = `${top}px`;
    }

    function showBetaTooltip(node, clientX, clientY) {
      if (!showDistributionHover || showDistributionAlways || !betaTooltip || !node) return;
      const posterior = node.posterior;
      if (!posterior) return;
      const label = node.branchKey ? getQuestionLabel(node.branchKey) : "Decision";
      const branch = node.branchValue === true ? "Yes" : "No";
      const hdi = node.hdi ? node.hdi[credibleLevel] : null;
      if (betaTooltipTitle) {
        betaTooltipTitle.textContent = `${label}: ${branch}`;
      }
      if (betaTooltipMeta) {
        const alphaText = formatBetaParam(posterior.alpha, useConfidenceWeights);
        const betaText = formatBetaParam(posterior.beta, useConfidenceWeights);
        betaTooltipMeta.textContent = `Beta(${alphaText}, ${betaText})`;
      }
      if (betaTooltipRange) {
        if (hdi && Number.isFinite(hdi.lower) && Number.isFinite(hdi.upper)) {
          const rangeText = formatPercentRange(hdi.lower, hdi.upper);
          const isTightWidth = window.matchMedia("(max-width: 650px)").matches;
          betaTooltipRange.textContent = isTightWidth ? rangeText : `HPD: ${rangeText}`;
        } else {
          betaTooltipRange.textContent = "Credible interval unavailable";
        }
      }
      drawBetaPlot(betaTooltipCanvas, posterior.alpha, posterior.beta, hdi);
      positionBetaTooltip(clientX, clientY);
      betaTooltip.classList.add("visible");
      betaTooltip.setAttribute("aria-hidden", "false");
      tooltipVisible = true;
    }

    function getTreeEvents() {
      return eventsData.filter((ev) => shouldIncludeEvent(ev));
    }

    function computeEventCounts() {
      const total = eventsData.length;
      const notPureH2 = eventsData.filter((ev) => ev.exclude_not_pure_h2).length;
      const notGaseousH2 = eventsData.filter((ev) => ev.exclude_not_gaseous_h2).length;
      const noLoc = eventsData.filter((ev) => ev.exclude_no_loc).length;
      const barrierImmediateCount = eventsData.filter((ev) => barrierImmediate(ev)).length;
      const barrierDelayedCount = eventsData.filter((ev) => barrierDelayed(ev)).length;
      return { total, notPureH2, notGaseousH2, noLoc, barrierImmediateCount, barrierDelayedCount };
    }

    function describeTreeSample(eventsForTree) {
      if (!eventsForTree.length) return "No events available for the tree.";
      return "";
    }

    function buildTreeLayout(events, treeDefinition, { useWeights = false, showDistribution = false } = {}) {
      const { decisions: decisionDefs, leaves: leafDefs, columns } = treeDefinition;
      const isCompactWidth = window.matchMedia("(max-width: 1400px)").matches;
      const isNarrowWidth = window.matchMedia("(max-width: 890px)").matches;
      const isExtraNarrowWidth = window.matchMedia("(max-width: 820px)").matches;
      const isUltraNarrowWidth = window.matchMedia("(max-width: 750px)").matches;
      const isMicroNarrowWidth = window.matchMedia("(max-width: 723px)").matches;
      const isTightWidth = window.matchMedia("(max-width: 650px)").matches;
      const isUltraTightWidth = window.matchMedia("(max-width: 600px)").matches;
      const isNanoWidth = window.matchMedia("(max-width: 565px)").matches;
      const isMicroNanoWidth = window.matchMedia("(max-width: 520px)").matches;
      const isPicoWidth = window.matchMedia("(max-width: 490px)").matches;
      
      const spacingY = showDistribution ? (isMicroNarrowWidth ? 93 : 103) : 58;
      const stepSpacing = showDistribution ? -10 : -15;
      const columnSpacing = isPicoWidth
        ? (showDistribution ? 86 : 91)
        : (showDistribution && isMicroNanoWidth)
          ? 88
          : isNanoWidth
            ? 93
            : (showDistribution && isUltraTightWidth)
              ? 98
              : isTightWidth
                ? 108
                : isMicroNarrowWidth
                  ? 118
                  : isExtraNarrowWidth
                    ? 130
                    : isNarrowWidth
                      ? 140
                      : isCompactWidth
                        ? 150
                        : 190;
      const baseX = isPicoWidth ? 20 : 30;
      const xPositions = {};
      columns.forEach((col, idx) => {
        xPositions[col.key] = baseX + idx * (columnSpacing + stepSpacing);
      });

      const sortKeys = ["continuous_release", "immediate_ignition", "delayed_ignition", "confined_space"];
      const orderedLeaves = [...leafDefs].sort((a, b) => {
        for (const key of sortKeys) {
          const av = a.conditions[key] === true ? 1 : 0;
          const bv = b.conditions[key] === true ? 1 : 0;
          if (av !== bv) return av - bv; // sort so Yes appears above No in the layout
        }
        return 0;
      });

      const startY = ((orderedLeaves.length - 1) * spacingY) / 2;
      const leaves = orderedLeaves.map((leaf, idx) => ({
        ...leaf,
        x: xPositions.outcome,
        y: startY - idx * spacingY,
        type: "outcome",
      }));

      const decisions = decisionDefs.map((node) => {
        const x = xPositions[node.column] ?? xPositions.root;
        return { ...node, x, type: "decision" };
      });

      const leafPositionsFor = (node) =>
        leaves.filter((leaf) => matchesConditions(leaf.conditions, node.conditions)).map((leaf) => leaf.y);

      decisions.forEach((node) => {
        const ys = leafPositionsFor(node);
        node.y = ys.length ? ys.reduce((sum, val) => sum + val, 0) / ys.length : 0;
      });

      const nodes = [...decisions, ...leaves];
      const nodeLookup = Object.fromEntries(nodes.map((node) => [node.id, node]));
      const conditionKey = (conditions) =>
        JSON.stringify(Object.entries(conditions || {}).sort((a, b) => a[0].localeCompare(b[0])));
      const matchesCache = new Map();
      const matchesFor = (conditions) => {
        const key = conditionKey(conditions);
        if (matchesCache.has(key)) return matchesCache.get(key);
        const matches = events.filter((ev) => matchesConditions(ev, conditions));
        matchesCache.set(key, matches);
        return matches;
      };

      nodes.forEach((node) => {
        const matches = matchesFor(node.conditions);
        node.count = matches.length;
      });

      nodes.forEach((node) => {
        const parent = node.parent ? nodeLookup[node.parent] : null;
        const branchKey = parent ? determineBranchKey(node.conditions, parent.conditions) : null;
        node.branchKey = branchKey;
        node.branchValue = branchKey ? node.conditions[branchKey] : null;

        if (!parent) {
          node.probability = 1;
          node.hdi = {};
          node.weightSum = null;
          node.parentWeightSum = null;
          node.posterior = null;
          return;
        }

        const parentMatches = matchesFor(parent.conditions);
        const nodeMatches = matchesFor(node.conditions);
        const weightFn = (ev) => confidenceWeight(ev, branchKey, useWeights);
        const parentWeightSum = parentMatches.reduce((sum, ev) => sum + weightFn(ev), 0);
        const nodeWeightSum = nodeMatches.reduce((sum, ev) => sum + weightFn(ev), 0);

        node.weightSum = nodeWeightSum;
        node.parentWeightSum = parentWeightSum;
        node.probability = parentWeightSum > 0 ? nodeWeightSum / parentWeightSum : 0;

        const posterior = computeBetaPosterior(nodeWeightSum, parentWeightSum);
        const masses = [0.5, 0.68, 0.95, 0.99];
        node.hdi = {};
        masses.forEach((mass) => {
          const hdi = posterior ? betaHighestDensityInterval(posterior.alpha, posterior.beta, mass) : null;
          node.hdi[mass] = hdi;
        });
        node.posterior = posterior;
      });

      const minY = Math.min(...nodes.map((n) => n.y));
      const maxY = Math.max(...nodes.map((n) => n.y));
      let marginTop = (showDistribution ? 130 : 110) - 10;
      if (isTightWidth) marginTop -= 10;
      const marginBottom = showDistribution ? 70 : 40;
      const marginX = isUltraNarrowWidth ? 10 : isExtraNarrowWidth ? 34 : isNarrowWidth ? 40 : 50;
      const offsetY = marginTop - minY;
      const offsetX = marginX;
      const height = maxY - minY + marginTop + marginBottom;
      const lastColumn = columns[columns.length - 1]?.key || "outcome";
      const width = (xPositions[lastColumn] ?? xPositions.outcome ?? 0) + marginX * 2;

      nodes.forEach((node) => {
        node.drawX = node.x + offsetX;
        node.drawY = node.y + offsetY;
      });

      const edges = nodes
        .filter((node) => node.parent)
        .map((node) => ({ from: node.parent, to: node.id }));

      const columnLabels = columns.map((col) => ({
        key: col.key,
        text: col.key === "root" ? "" : col.label,
        x: (xPositions[col.key] ?? 0) + offsetX,
      }));

      return { nodes, edges, width, height, columnLabels };
    }

    function getTreeNodePositions(container) {
      const positions = {};
      if (!container) return positions;
      container.querySelectorAll(".tree-node").forEach((node) => {
        const id = node.dataset.nodeId;
        const left = parseFloat(node.style.left);
        const top = parseFloat(node.style.top);
        if (!id || !Number.isFinite(left) || !Number.isFinite(top)) return;
        positions[id] = { x: left, y: top };
      });
      return positions;
    }

    function getTreeEdgePaths(container) {
      const paths = {};
      if (!container) return paths;
      container.querySelectorAll(".tree-edge").forEach((edge) => {
        const id = edge.dataset.edgeId;
        const d = edge.getAttribute("d");
        if (!id || !d) return;
        paths[id] = d;
      });
      return paths;
    }

    function parseEdgePath(d) {
      const nums = d.match(/-?\d*\.?\d+/g);
      if (!nums || nums.length !== 8) return null;
      const coords = nums.map(Number);
      return coords.every((val) => Number.isFinite(val)) ? coords : null;
    }

    function buildEdgePath(coords) {
      return `M ${coords[0]} ${coords[1]} L ${coords[2]} ${coords[3]} L ${coords[4]} ${coords[5]} L ${coords[6]} ${coords[7]}`;
    }

    function animateEdgePaths(animations) {
      if (!animations.length) return;
      const duration = 260;
      const start = typeof performance !== "undefined" ? performance.now() : Date.now();
      const schedule = typeof requestAnimationFrame === "function"
        ? requestAnimationFrame
        : (cb) => setTimeout(() => cb(Date.now()), 16);
      const step = (now) => {
        const time = typeof performance !== "undefined" ? now : Date.now();
        const t = Math.min((time - start) / duration, 1);
        const eased = 1 - Math.pow(1 - t, 3);
        animations.forEach(({ path, from, to }) => {
          const coords = from.map((val, idx) => val + (to[idx] - val) * eased);
          path.setAttribute("d", buildEdgePath(coords));
        });
        if (t < 1) {
          schedule(step);
        }
      };
      schedule(step);
    }

    function getTreeLabelPositions(container) {
      const positions = {};
      if (!container) return positions;
      container.querySelectorAll(".tree-column-label").forEach((label) => {
        const key = label.dataset.column;
        const left = parseFloat(label.style.left);
        if (!key || !Number.isFinite(left)) return;
        positions[key] = { x: left };
      });
      return positions;
    }

    function animateTreeLabelPositions(labelElements, previousPositions) {
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
      if (!previousPositions || !Object.keys(previousPositions).length) return;
      const updates = [];
      Object.entries(labelElements).forEach(([key, el]) => {
        const prev = previousPositions[key];
        if (!prev) return;
        const left = parseFloat(el.style.left);
        if (!Number.isFinite(left)) return;
        const dx = prev.x - left;
        if (Math.abs(dx) < 1) return;
        updates.push(el);
      });
      if (!updates.length) return;
      const applyNextShift = () => {
        updates.forEach((el) => {
          el.style.setProperty("--shift-x", "0px");
          el.style.setProperty("--shift-y", "0px");
        });
      };
      if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(applyNextShift);
      } else {
        applyNextShift();
      }
    }

    function animateTreeContainerHeight(container, previousHeight, nextHeight) {
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
        container.style.minHeight = `${nextHeight}px`;
        container.style.height = "";
        return;
      }
      if (!Number.isFinite(previousHeight) || !Number.isFinite(nextHeight)) return;
      if (previousHeight < 1) {
        container.style.minHeight = `${nextHeight}px`;
        container.style.height = "";
        return;
      }
      if (Math.abs(nextHeight - previousHeight) < 1) {
        container.style.minHeight = `${nextHeight}px`;
        container.style.height = "";
        return;
      }
      const isExpanding = nextHeight > previousHeight;
      container.style.minHeight = `${previousHeight}px`;
      container.style.height = `${previousHeight}px`;
      const clearHeight = (event) => {
        if (event.propertyName !== "height") return;
        container.removeEventListener("transitionend", clearHeight);
        container.style.height = "";
        container.style.minHeight = `${nextHeight}px`;
      };
      container.addEventListener("transitionend", clearHeight);
      const applyNextHeight = () => {
        if (!isExpanding) {
          container.style.minHeight = `${nextHeight}px`;
        }
        container.style.height = `${nextHeight}px`;
      };
      if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(applyNextHeight);
      } else {
        applyNextHeight();
      }
    }

    function animateTreeNodePositions(nodeElements, previousPositions) {
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
      if (!previousPositions || !Object.keys(previousPositions).length) return;
      const updates = [];
      Object.entries(nodeElements).forEach(([id, el]) => {
        const prev = previousPositions[id];
        if (!prev) return;
        const left = parseFloat(el.style.left);
        const top = parseFloat(el.style.top);
        if (!Number.isFinite(left) || !Number.isFinite(top)) return;
        const dx = prev.x - left;
        const dy = prev.y - top;
        if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;
        updates.push(el);
      });
      if (!updates.length) return;
      const applyNextShift = () => {
        updates.forEach((el) => {
          el.style.setProperty("--shift-x", "0px");
          el.style.setProperty("--shift-y", "0px");
        });
      };
      if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(applyNextShift);
      } else {
        applyNextShift();
      }
    }

    function getTreeNodeHeights(container) {
      const heights = {};
      if (!container) return heights;
      container.querySelectorAll(".tree-node").forEach((node) => {
        const id = node.dataset.nodeId;
        if (!id) return;
        heights[id] = node.getBoundingClientRect().height;
      });
      return heights;
    }

    function animateTreeNodeHeights(nodeElements, previousHeights) {
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
      if (!previousHeights || !Object.keys(previousHeights).length) return;
      const updates = [];
      Object.entries(nodeElements).forEach(([id, el]) => {
        const prevHeight = previousHeights[id];
        if (!Number.isFinite(prevHeight)) return;
        const nextHeight = el.getBoundingClientRect().height;
        if (!Number.isFinite(nextHeight) || Math.abs(nextHeight - prevHeight) < 1) return;
        updates.push({ el, prevHeight, nextHeight });
      });
      if (!updates.length) return;
      updates.forEach(({ el, prevHeight }) => {
        el.style.height = `${prevHeight}px`;
        el.style.overflow = "hidden";
      });
      const applyNextHeights = () => {
        updates.forEach(({ el, nextHeight }) => {
          const clearHeight = (event) => {
            if (event.propertyName !== "height") return;
            el.removeEventListener("transitionend", clearHeight);
            el.style.height = "";
            el.style.overflow = "";
          };
          el.addEventListener("transitionend", clearHeight);
          el.style.height = `${nextHeight}px`;
        });
      };
      if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(applyNextHeights);
      } else {
        applyNextHeights();
      }
    }

    function renderEventTree(events, treeDefinition, options = {}) {
      const showCredible = options.showCredible ?? true;
      const credibleLevel = options.credibleLevel ?? 0.95;
      const showCounts = options.showCounts ?? true;
      const showProbability = options.showProbability ?? true;
      const showDistribution = options.showDistribution ?? false;
      const useWeights = options.useWeights || false;
      const summaryText = options.summaryText || "";
      const isMicroNarrowWidth = window.matchMedia("(max-width: 723px)").matches;
      const isTightWidth = window.matchMedia("(max-width: 650px)").matches;
      const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      const container = document.getElementById(options.containerId || "treeContainer");
      const status = document.getElementById(options.statusId || "treeStatus");
      if (!container) return;
      const previousContainerHeight = container.getBoundingClientRect().height;
      const previousEdgePaths = getTreeEdgePaths(container);
      const previousPositions = getTreeNodePositions(container);
      const previousLabelPositions = getTreeLabelPositions(container);
      const previousHeights = getTreeNodeHeights(container);
      if (!events || events.length === 0) {
        if (status) {
          status.textContent = summaryText || "No events available for the tree.";
        }
        container.innerHTML = "";
        adjustTreeOverflow(container);
        return;
      }

      const { nodes, edges, width, height, columnLabels } = buildTreeLayout(events, treeDefinition, {
        useWeights,
        showDistribution,
      });
      const nodeLookup = Object.fromEntries(nodes.map((node) => [node.id, node]));
      const nodeElements = {};
      const labelElements = {};

      hideBetaTooltip();
      if (status) {
        status.textContent = summaryText;
      }
      container.innerHTML = "";
      const minHeight = showDistribution ? 669 : 430;
      const nextHeight = Math.max(height + 1, minHeight);
      const containerStyles = getComputedStyle(container);
      const padLeft = parseFloat(containerStyles.paddingLeft) || 0;
      const padRight = parseFloat(containerStyles.paddingRight) || 0;
      container.style.width = "100%";
      container.style.minWidth = "0";
      container.style.maxWidth = "100%";

      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
      svg.setAttribute("width", width);
      svg.setAttribute("height", height);
      svg.style.width = `${width}px`;
      svg.style.height = `${height}px`;
      svg.classList.add("tree-svg");

      const CONNECTOR_INSET = 14;
      const edgeAnimations = [];

      edges.forEach((edge) => {
        const from = nodeLookup[edge.from];
        const to = nodeLookup[edge.to];
        if (!from || !to) return;
        const startX = from.drawX + CONNECTOR_INSET;
        const endX = to.drawX - CONNECTOR_INSET;
        const midX = (startX + endX) / 2;
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const edgeId = `${edge.from}->${edge.to}`;
        const nextCoords = [startX, from.drawY, midX, from.drawY, midX, to.drawY, endX, to.drawY];
        const nextD = buildEdgePath(nextCoords);
        path.classList.add("tree-edge");
        path.dataset.edgeId = edgeId;
        if (!reduceMotion && treeReady) {
          const prevCoords = parseEdgePath(previousEdgePaths[edgeId] || "");
          if (prevCoords) {
            path.setAttribute("d", buildEdgePath(prevCoords));
            edgeAnimations.push({ path, from: prevCoords, to: nextCoords });
          } else {
            path.setAttribute("d", nextD);
          }
        } else {
          path.setAttribute("d", nextD);
        }
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "#4b5563");
        path.setAttribute("stroke-width", "1.4");
        svg.appendChild(path);
      });

      container.appendChild(svg);

      columnLabels.forEach((col) => {
        if (!col.text) return;
        const label = document.createElement("div");
        label.className = "tree-column-label";
        label.style.left = `${col.x}px`;
        label.dataset.column = col.key;
        const prevPos = previousLabelPositions[col.key];
        if (!reduceMotion && prevPos) {
          const dx = prevPos.x - col.x;
          if (Math.abs(dx) >= 1) {
            label.style.setProperty("--shift-x", `${dx}px`);
            label.style.setProperty("--shift-y", "0px");
          }
        }
        label.textContent = col.text;
        container.appendChild(label);
        labelElements[col.key] = label;
      });

      nodes.forEach((node) => {
        const el = document.createElement("div");
        el.className = "tree-node";
        el.style.left = `${node.drawX}px`;
        el.style.top = `${node.drawY}px`;
        const prevPos = previousPositions[node.id];
        if (!reduceMotion && prevPos) {
          const dx = prevPos.x - node.drawX;
          const dy = prevPos.y - node.drawY;
          if (Math.abs(dx) >= 1 || Math.abs(dy) >= 1) {
            el.style.setProperty("--shift-x", `${dx}px`);
            el.style.setProperty("--shift-y", `${dy}px`);
          }
        }

        const title = document.createElement("div");
        title.className = "node-title";
        const baseTitle = node.label;
        const isOutcome = node.type === "outcome";
        const isRoot = node.type === "decision" && !node.parent;
        const hasProbability = node.type !== "outcome" && node.parent;
        const showMetaCount = showCounts && isRoot;
        if (isRoot) el.classList.add("tree-root");

        let titleLine = baseTitle;
        const detailParts = [];
        if (hasProbability && showProbability) {
          detailParts.push(formatPercent(node.probability));
        }
        if (showCounts && hasProbability) {
          detailParts.push(`(${node.count})`);
        }
        if (detailParts.length) {
          titleLine += ` ${detailParts.join(" ")}`;
        }
        title.textContent = titleLine;

        const prob = document.createElement("div");
        prob.className = "node-prob";
        let probLine = "";
        const hdi = hasProbability ? (node.hdi ? node.hdi[credibleLevel] : null) : null;
        if (hasProbability && showCredible) {
          if (hdi && Number.isFinite(hdi.lower) && Number.isFinite(hdi.upper)) {
            const rangeText = formatPercentRange(hdi.lower, hdi.upper);
            probLine = isTightWidth ? rangeText : `HPD: ${rangeText}`;
          }
        }
        prob.innerHTML = probLine;

        const meta = document.createElement("div");
        meta.className = "node-meta";
        meta.textContent = `${node.count} obs.`;

        el.dataset.nodeId = node.id;
        el.dataset.parentId = node.parent || "";
        el.appendChild(title);
        if (probLine) el.appendChild(prob);
        if (showMetaCount) el.appendChild(meta);

        const showPosterior = showDistribution && hasProbability && node.posterior;
        if (showPosterior) {
          el.classList.add("with-distribution");
          const dist = document.createElement("div");
          dist.className = "node-distribution";
          const distCanvas = document.createElement("canvas");
          distCanvas.width = 120;
          distCanvas.height = isMicroNarrowWidth ? 30 : 40;
          dist.appendChild(distCanvas);
          el.appendChild(dist);
          const hdiForPlot = showCredible ? hdi : null;
          drawBetaPlot(distCanvas, node.posterior.alpha, node.posterior.beta, hdiForPlot);
        }
        container.appendChild(el);
        nodeElements[node.id] = el;

        if (node.type === "decision" && node.parent) {
          el.classList.add("clickable");
          el.addEventListener("click", () => {
            applyTreeFilter(node.conditions);
          });
        }

        if (node.type === "outcome") {
          const chainIds = [];
          let cursor = node;
          while (cursor) {
            chainIds.push(cursor.id);
            cursor = cursor.parent ? nodeLookup[cursor.parent] : null;
          }
          const clearHighlight = () => {
            Object.values(nodeElements).forEach((elem) => elem.classList.remove("highlight"));
          };
          const applyHighlight = () => {
            clearHighlight();
            chainIds.forEach((id) => {
              const elem = nodeElements[id];
              if (elem) elem.classList.add("highlight");
            });
          };
          el.addEventListener("mouseenter", applyHighlight);
          el.addEventListener("mouseleave", clearHighlight);
        }

        if (node.type === "decision" && node.parent && !showDistribution) {
          el.addEventListener("mouseenter", (event) => {
            showBetaTooltip(node, event.clientX, event.clientY);
          });
          el.addEventListener("mousemove", (event) => {
            if (showDistributionHover && !showDistributionAlways && tooltipVisible) {
              positionBetaTooltip(event.clientX, event.clientY);
            }
          });
          el.addEventListener("mouseleave", () => {
            hideBetaTooltip();
          });
        }
      });

      animateTreeNodePositions(nodeElements, previousPositions);
      animateTreeLabelPositions(labelElements, previousLabelPositions);
      animateTreeNodeHeights(nodeElements, previousHeights);
      if (!reduceMotion && treeReady) {
        animateEdgePaths(edgeAnimations);
      }
      if (treeReady) {
        animateTreeContainerHeight(container, previousContainerHeight, nextHeight);
      } else {
        container.style.minHeight = `${nextHeight}px`;
        container.style.height = "";
      }
      treeReady = true;
      adjustTreeOverflow(container);
    }

    function adjustTreeOverflow(container) {
      if (!container) return;
      const updateOverflow = () => {
        container.style.overflowX = "auto";
        container.style.overflowY = "hidden";
      };
      if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(updateOverflow);
      } else {
        updateOverflow();
      }
    }

    function updateControlCounts() {
      const counts = computeEventCounts();
      const notPureLabel = document.getElementById("labelNotPureH2");
      const notGaseousLabel = document.getElementById("labelNotGaseousH2");
      const noLocLabel = document.getElementById("labelNoLoc");
      const barrierImmediateLabel = document.getElementById("labelBarrierImmediate");
      const barrierDelayedLabel = document.getElementById("labelBarrierDelayed");
      if (notPureLabel) notPureLabel.textContent = `Include not pure H2 (${counts.notPureH2})`;
      if (notGaseousLabel) notGaseousLabel.textContent = `Include not gaseous H2 (${counts.notGaseousH2})`;
      if (noLocLabel) noLocLabel.textContent = `Include no loss of containment (${counts.noLoc})`;
      if (barrierImmediateLabel) barrierImmediateLabel.textContent = `Include barrier-stopped immediate ignition (${counts.barrierImmediateCount})`;
      if (barrierDelayedLabel) barrierDelayedLabel.textContent = `Include barrier-stopped delayed ignition (${counts.barrierDelayedCount})`;
    }

    function updateTree() {
      updateControlCounts();
      const eventsForTree = getTreeEvents();
      const summary = eventsForTree.length ? "" : "No events available for the tree.";
      renderEventTree(eventsForTree, TREE_DEFINITION, {
        showCounts,
        showProbability,
        showCredible,
        credibleLevel,
        showDistribution: showDistributionAlways,
        summaryText: summary,
        useWeights: useConfidenceWeights,
        containerId: "treeContainer",
        statusId: "treeStatus",
      });
    }

    function selectEvent(idx) {
      const prev = selectedIndex;
      selectedIndex = idx;
      document.querySelectorAll(".event").forEach(el => el.classList.remove("active"));
      const active = document.querySelector(`.event[data-index='${idx}']`);
      if (active) active.classList.add("active");
      const ev = eventsData[idx];
      if (!ev) return;
      const details = document.getElementById("details");
      const model = escapeHtml(ev.model || "unknown");
      const outcome = escapeHtml(ev.outcome || inferOutcome(ev) || "");
      const thinking = ev.thinking ? "Enabled" : "Disabled";
      const sys = escapeHtml(ev.system_prompt || "N/A");
      const userPrompt = escapeHtml(ev.user_prompt || "No prompt captured.");
      const reasoning = escapeHtml(ev.reasoning || "No reasoning trace captured.");
      const description = escapeHtml(ev.description || "No description available.");
      const excluded = !!(
        ev.exclude_not_pure_h2 ||
        ev.exclude_not_gaseous_h2 ||
        ev.exclude_no_loc
      );
      const statusClass = excluded ? "badge bad" : "badge good";
      details.classList.remove("muted", "empty-state");
      details.innerHTML = `
        <button class="all-events-button" type="button">All events</button>
        <div class="card">
          <div class="card-header details-header">
            <h2 class="card-title-main">${escapeHtml(ev.title || "Untitled Event")}</h2>
            <div class="${statusClass}">${excluded ? "Excluded" : "Included"}</div>
          </div>
          <div class="pill">Event ID: <span class="pill-value">${escapeHtml(ev.event_id || "N/A")}</span></div>
          ${outcome ? `<div class="pill">Outcome: <span class="pill-value">${outcome}</span></div>` : ""}
          <div class="pill">Model: <span class="pill-value">${model}</span></div>
          <div class="pill">Thinking: <span class="pill-value">${thinking}</span></div>
          <div class="card-section">
            <h2>Event Description</h2>
            <pre>${description}</pre>
          </div>
        </div>
        <div class="card">
          <h2>Model Answers</h2>
          ${renderAnswers(ev)}
        </div>
        <div class="card">
          <h2>LLM User Message</h2>
          <pre>${userPrompt}</pre>
        </div>
        <div class="card">
          <h2>System Prompt</h2>
          <pre>${sys}</pre>
        </div>
        <div class="card">
          <h2>Reasoning Trace</h2>
          <pre>${reasoning}</pre>
        </div>
      `;
      if (prev !== idx) {
        details.classList.remove("details-animate");
        // Force reflow so the animation restarts on each selection.
        void details.offsetWidth;
        details.classList.add("details-animate");
      }
      const allEventsButton = details.querySelector(".all-events-button");
      if (allEventsButton) {
        allEventsButton.addEventListener("click", () => {
          setListOverlayOpen(true);
        });
      }
      updateAllEventsButtonCount();
      setListOverlayOpen(false);
      const content = document.querySelector(".content");
      if (content && prev !== idx) {
        content.scrollTop = 0;
      }
    }

    const treeWidthQueries = {
      compact: window.matchMedia("(max-width: 1400px)"),
      narrow: window.matchMedia("(max-width: 890px)"),
      extraNarrow: window.matchMedia("(max-width: 820px)"),
      ultraNarrow: window.matchMedia("(max-width: 750px)"),
      microNarrow: window.matchMedia("(max-width: 723px)"),
      tightNarrow: window.matchMedia("(max-width: 650px)"),
      ultraTight: window.matchMedia("(max-width: 600px)"),
      nano: window.matchMedia("(max-width: 565px)"),
      microNano: window.matchMedia("(max-width: 520px)"),
      pico: window.matchMedia("(max-width: 490px)"),
    };
    let lastTreeWidthState = {
      compact: treeWidthQueries.compact.matches,
      narrow: treeWidthQueries.narrow.matches,
      extraNarrow: treeWidthQueries.extraNarrow.matches,
      ultraNarrow: treeWidthQueries.ultraNarrow.matches,
      microNarrow: treeWidthQueries.microNarrow.matches,
      tightNarrow: treeWidthQueries.tightNarrow.matches,
      ultraTight: treeWidthQueries.ultraTight.matches,
      nano: treeWidthQueries.nano.matches,
      microNano: treeWidthQueries.microNano.matches,
      pico: treeWidthQueries.pico.matches,
    };
    const handleTreeWidthChange = () => {
      const nextState = {
        compact: treeWidthQueries.compact.matches,
        narrow: treeWidthQueries.narrow.matches,
        extraNarrow: treeWidthQueries.extraNarrow.matches,
        ultraNarrow: treeWidthQueries.ultraNarrow.matches,
        microNarrow: treeWidthQueries.microNarrow.matches,
        tightNarrow: treeWidthQueries.tightNarrow.matches,
        ultraTight: treeWidthQueries.ultraTight.matches,
        nano: treeWidthQueries.nano.matches,
        microNano: treeWidthQueries.microNano.matches,
        pico: treeWidthQueries.pico.matches,
      };
      if (
        nextState.compact === lastTreeWidthState.compact &&
        nextState.narrow === lastTreeWidthState.narrow &&
        nextState.extraNarrow === lastTreeWidthState.extraNarrow &&
        nextState.ultraNarrow === lastTreeWidthState.ultraNarrow &&
        nextState.microNarrow === lastTreeWidthState.microNarrow &&
        nextState.tightNarrow === lastTreeWidthState.tightNarrow &&
        nextState.ultraTight === lastTreeWidthState.ultraTight &&
        nextState.nano === lastTreeWidthState.nano &&
        nextState.microNano === lastTreeWidthState.microNano &&
        nextState.pico === lastTreeWidthState.pico
      ) {
        return;
      }
      lastTreeWidthState = nextState;
      if (treeReady) updateTree();
    };
    Object.values(treeWidthQueries).forEach((query) => {
      if (typeof query.addEventListener === "function") {
        query.addEventListener("change", handleTreeWidthChange);
      } else if (typeof query.addListener === "function") {
        query.addListener(handleTreeWidthChange);
      }
    });

    function setEmptyState(message) {
      const details = document.getElementById("details");
      details.classList.add("muted", "empty-state");
      details.textContent = message;
      document.getElementById("list").innerHTML = "";
      const treeContainer = document.getElementById("treeContainer");
      if (treeContainer) treeContainer.innerHTML = "";
    }

    const listOverlayQuery = window.matchMedia("(max-width: 550px)");

    function setListOverlayOpen(open) {
      if (!listOverlayQuery.matches) {
        document.body.removeAttribute("data-list-overlay");
        return;
      }
      if (open) {
        document.body.setAttribute("data-list-overlay", "open");
      } else {
        document.body.removeAttribute("data-list-overlay");
      }
    }

    const handleListOverlayChange = () => {
      if (!listOverlayQuery.matches) {
        document.body.removeAttribute("data-list-overlay");
      }
    };
    if (typeof listOverlayQuery.addEventListener === "function") {
      listOverlayQuery.addEventListener("change", handleListOverlayChange);
    } else if (typeof listOverlayQuery.addListener === "function") {
      listOverlayQuery.addListener(handleListOverlayChange);
    }

    function setTab(tab) {
      currentTab = tab;
      localStorage.setItem("hiad-tab", tab);
      document.querySelectorAll(".tab-button").forEach((b) => b.classList.remove("active"));
      document.querySelectorAll(".tab-panel").forEach((panel) => panel.classList.remove("active"));
      const btn = document.querySelector(`.tab-button[data-tab='${tab}']`);
      if (btn) btn.classList.add("active");
      const panel = document.getElementById(`${tab}Panel`);
      if (panel) panel.classList.add("active");
      document.body.setAttribute("data-view", tab);
      setListOverlayOpen(false);
    }

    function setAboutOpen(open) {
      const modal = document.getElementById("aboutModal");
      if (!modal) return;
      if (open) {
        document.body.setAttribute("data-about-open", "true");
        modal.setAttribute("aria-hidden", "false");
      } else {
        document.body.removeAttribute("data-about-open");
        modal.setAttribute("aria-hidden", "true");
      }
    }

    async function loadEvents() {
      try {
        const response = await fetch("events.json", { cache: "no-cache" });
        if (!response.ok) throw new Error(`Failed to load events: ${response.statusText}`);
        eventsData = await response.json();
        if (!Array.isArray(eventsData)) throw new Error("events.json is not an array");
        if (eventsData.length === 0) {
          setEmptyState("No events found in events.json.");
          return;
        }
        refreshList({ ensureSelection: true });
        updateTree();
      } catch (err) {
        console.error(err);
        setEmptyState("Unable to load events.json. Check the server output for details.");
      }
    }

    (function init() {
      const storedTab = localStorage.getItem("hiad-tab") || "tree";
      setTab(storedTab);
      const aboutButton = document.getElementById("aboutButton");
      const aboutClose = document.getElementById("aboutClose");
      const aboutOverlay = document.querySelector(".about-modal-overlay");
      if (aboutButton) {
        aboutButton.addEventListener("click", () => {
          setAboutOpen(true);
        });
      }
      if (aboutClose) {
        aboutClose.addEventListener("click", () => {
          setAboutOpen(false);
        });
      }
      if (aboutOverlay) {
        aboutOverlay.addEventListener("click", () => {
          setAboutOpen(false);
        });
      }
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && document.body.getAttribute("data-about-open") === "true") {
          setAboutOpen(false);
        }
      });
      const sortSelect = document.getElementById("sortSelect");
      if (sortSelect) {
        sortMode = sortSelect.value || "id";
        sortSelect.addEventListener("change", (e) => {
          sortMode = e.target.value;
          refreshList({ ensureSelection: true });
        });
      }
      const includeNotPure = document.getElementById("includeNotPureH2");
      const includeNotGaseous = document.getElementById("includeNotGaseousH2");
      const includeNoLocToggle = document.getElementById("includeNoLoc");
      const includeBarrier1 = document.getElementById("includeBarrierImmediate");
      const includeBarrier2 = document.getElementById("includeBarrierDelayed");

      if (includeNotPure) {
        includeNotPureH2 = includeNotPure.checked;
        includeNotPure.addEventListener("change", (e) => {
          includeNotPureH2 = e.target.checked;
          updateTree();
          refreshList({ ensureSelection: true });
        });
      }
      if (includeNotGaseous) {
        includeNotGaseousH2 = includeNotGaseous.checked;
        includeNotGaseous.addEventListener("change", (e) => {
          includeNotGaseousH2 = e.target.checked;
          updateTree();
          refreshList({ ensureSelection: true });
        });
      }
      if (includeNoLocToggle) {
        includeNoLoc = includeNoLocToggle.checked;
        includeNoLocToggle.addEventListener("change", (e) => {
          includeNoLoc = e.target.checked;
          updateTree();
          refreshList({ ensureSelection: true });
        });
      }
      if (includeBarrier1) {
        includeBarrierImmediate = includeBarrier1.checked;
        includeBarrier1.addEventListener("change", (e) => {
          includeBarrierImmediate = e.target.checked;
          updateTree();
          refreshList({ ensureSelection: true });
        });
      }
      if (includeBarrier2) {
        includeBarrierDelayed = includeBarrier2.checked;
        includeBarrier2.addEventListener("change", (e) => {
          includeBarrierDelayed = e.target.checked;
          updateTree();
          refreshList({ ensureSelection: true });
        });
      }
      const countsToggle = document.getElementById("toggleCounts");
      const probToggle = document.getElementById("toggleProbability");
      const credibleToggle = document.getElementById("toggleCredible");
      const distributionAlwaysToggle = document.getElementById("toggleDistributionAlways");
      const credLevelContainer = document.getElementById("credLevelControls");
      const credLevelRadios = document.querySelectorAll("input[name='credLevel']");

      const updateCredLevelState = () => {
        const enabled = credibleToggle ? credibleToggle.checked : false;
        if (credLevelContainer) {
          credLevelContainer.classList.toggle("disabled", !enabled);
        }
        credLevelRadios.forEach((radio) => {
          radio.disabled = !enabled;
        });
        if (distributionAlwaysToggle) {
          distributionAlwaysToggle.disabled = !enabled;
          if (!enabled) {
            distributionAlwaysToggle.checked = false;
            showDistributionAlways = false;
          }
        }
      };

      if (countsToggle) {
        showCounts = countsToggle.checked;
        countsToggle.addEventListener("change", (e) => {
          showCounts = e.target.checked;
          updateTree();
        });
      }
      if (probToggle) {
        showProbability = probToggle.checked;
        probToggle.addEventListener("change", (e) => {
          showProbability = e.target.checked;
          updateTree();
        });
      }
      if (credibleToggle) {
        showCredible = credibleToggle.checked;
        credibleToggle.addEventListener("change", (e) => {
          showCredible = e.target.checked;
          updateCredLevelState();
          updateTree();
        });
      }
      if (distributionAlwaysToggle) {
        showDistributionAlways = distributionAlwaysToggle.checked;
        distributionAlwaysToggle.addEventListener("change", (e) => {
          showDistributionAlways = e.target.checked;
          if (showDistributionAlways) {
            hideBetaTooltip();
          }
          updateTree();
        });
      }
      const confidenceWeightsToggle = document.getElementById("toggleConfidenceWeights");
      if (confidenceWeightsToggle) {
        useConfidenceWeights = confidenceWeightsToggle.checked;
        confidenceWeightsToggle.addEventListener("change", (e) => {
          useConfidenceWeights = e.target.checked;
          updateTree();
        });
      }
      credLevelRadios.forEach((radio) => {
        if (radio.checked) {
          credibleLevel = Number(radio.value);
        }
        radio.addEventListener("change", (e) => {
          if (e.target.checked) {
            credibleLevel = Number(e.target.value);
            updateTree();
          }
        });
      });
      updateCredLevelState();
      document.querySelectorAll(".tab-button").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const tab = e.currentTarget.dataset.tab;
          setTab(tab);
        });
      });
      loadEvents();
    })();
  </script>
</body>
</html>
